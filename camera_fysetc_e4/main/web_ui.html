<!DOCTYPE html>
<html><head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PTZ Camera Control</title>
<style>
body { font-family: Arial, sans-serif; margin: 20px; background: #f0f0f0; }
.container { max-width: 800px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
h1 { color: #333; text-align: center; }
.section { margin: 20px 0; padding: 15px; background: #f9f9f9; border-radius: 5px; }
.section h2 { margin-top: 0; color: #555; }
.control-group { margin: 15px 0; }
label { display: block; margin-bottom: 5px; font-weight: bold; color: #666; }
input[type="range"] { width: 100%; margin: 10px 0; }
input[type="text"] { width: 100px; padding: 5px; margin: 0 10px; }
button { padding: 10px 20px; margin: 5px; font-size: 16px; cursor: pointer; border: none; border-radius: 5px; }
.btn-primary { background: #4CAF50; color: white; }
.btn-primary:hover { background: #45a049; }
.btn-secondary { background: #2196F3; color: white; }
.btn-secondary:hover { background: #0b7dda; }
.btn-danger { background: #f44336; color: white; }
.btn-danger:hover { background: #da190b; }
.btn-warning { background: #ff9800; color: white; }
.btn-warning:hover { background: #e68900; }
.status { padding: 10px; margin: 10px 0; border-radius: 5px; }
.status-info { background: #e3f2fd; color: #1976d2; }
.status-success { background: #e8f5e9; color: #388e3c; }
#positions { font-family: monospace; font-size: 18px; }
.preset-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px; margin: 10px 0; }
.preset-btn { padding: 15px; font-size: 14px; position: relative; }
.preset-edit-btn { position: absolute; top: 2px; right: 2px; padding: 2px 6px; font-size: 10px; background: rgba(0,0,0,0.5); color: white; border: none; border-radius: 3px; cursor: pointer; }
.preset-edit-btn:hover { background: rgba(0,0,0,0.7); }
.modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); }
.modal-content { background: white; margin: 5% auto; padding: 20px; border-radius: 10px; width: 90%; max-width: 600px; max-height: 80vh; overflow-y: auto; }
.modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
.close { color: #aaa; font-size: 28px; font-weight: bold; cursor: pointer; }
.close:hover { color: #000; }
.form-group { margin: 15px 0; }
.form-group label { display: block; margin-bottom: 5px; font-weight: bold; }
.form-group input, .form-group select { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; }
.form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
.joystick-container { display: flex; gap: 20px; margin: 20px 0; flex-wrap: wrap; }
.joystick-wrapper { display: flex; flex-direction: column; align-items: center; }
.joystick-2d { width: 200px; height: 200px; border: 3px solid #333; border-radius: 50%; position: relative; background: #f5f5f5; cursor: crosshair; touch-action: none; }
.joystick-2d::before { content: ''; position: absolute; width: 30px; height: 30px; background: #4CAF50; border-radius: 50%; top: calc(50% + var(--y, 0px)); left: calc(50% + var(--x, 0px)); transform: translate(-50%, -50%); transition: transform 0.05s; }
.joystick-2d.active::before { background: #45a049; }
.joystick-1d { width: 60px; height: 200px; border: 3px solid #333; border-radius: 30px; position: relative; background: #f5f5f5; cursor: ns-resize; touch-action: none; }
.joystick-1d::before { content: ''; position: absolute; width: 50px; height: 30px; background: #2196F3; border-radius: 15px; left: 50%; top: calc(50% + var(--y, 0px)); transform: translate(-50%, -50%); transition: top 0.05s; }
.joystick-1d.active::before { background: #0b7dda; }
.joystick-label { margin-top: 10px; font-weight: bold; color: #666; }
.joystick-value { margin-top: 5px; font-family: monospace; color: #333; }
</style>
</head><body>
<div class="container">
<h1>PTZ Camera Control</h1>
<div class="section">
<h2>Position Status</h2>
<div id="positions" class="status status-info">Loading...</div>
</div>
<div class="section">
<h2>Joystick Control</h2>
<div class="joystick-container">
<div class="joystick-wrapper">
<div class="joystick-label">PAN & TILT</div>
<div id="joystick_xy" class="joystick-2d"></div>
<div class="joystick-value" id="xy_value">X: 0.0, Y: 0.0</div>
</div>
<div class="joystick-wrapper">
<div class="joystick-label">ZOOM</div>
<div id="joystick_z" class="joystick-1d"></div>
<div class="joystick-value" id="z_value">Z: 0.0</div>
</div>
</div>
</div>
<div class="section">
<h2>Velocity Control (Sliders)</h2>
<div class="control-group">
<label>PAN: <span id="pan_val">0.0</span> steps/s</label>
%SLIDER_PAN%
</div>
<div class="control-group">
<label>TILT: <span id="tilt_val">0.0</span> steps/s</label>
%SLIDER_TILT%
</div>
<div class="control-group">
<label>ZOOM: <span id="zoom_val">0.0</span> steps/s</label>
%SLIDER_ZOOM%
</div>
</div>
<div class="section">
<h2>Commands</h2>
<button class="btn-primary" onclick="sendCommand('home')">Home All Axes</button>
<button class="btn-danger" onclick="sendCommand('stop')">Stop</button>
<button class="btn-secondary" onclick="sendCommand('precision')">Toggle Precision</button>
</div>
<div class="section">
<h2>Tilt Limit Calibration</h2>
<p style="color: #666; font-size: 14px;">Calibrate tilt axis limits by setting the midpoint (home position) and two physical stops (Down and Up). The system calculates the values needed to update in <code>motion_planner.h</code>. Note: Down angle (negative) will be less than Up angle (positive).</p>
<p style="color: #666; font-size: 13px; margin-top: 10px;"><strong>Instructions:</strong></p>
<ol style="color: #666; font-size: 13px; margin-left: 20px; margin-top: 5px;">
<li><strong>Home the camera first</strong> (click "Home All Axes" above) - this sets the midpoint to position 0</li>
<li>Click "Set Midpoint" to capture the home position (should be 0 or close to 0)</li>
<li>Move the camera to the <strong>down</strong> physical stop and click "Set Stop Down"</li>
<li>Move the camera to the <strong>up</strong> physical stop and click "Set Stop Up"</li>
<li>Click "Calculate Values" to get the calibration results</li>
<li>Update the calculated values in <code>motion_planner.h</code> and rebuild the firmware</li>
</ol>
<p style="color: #d32f2f; font-size: 12px; margin-top: 10px; font-weight: bold;">⚠️ Important: The camera must reset to the same midpoint position after homing for the calculated limits to work correctly.</p>
<div style="margin: 15px 0;">
<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 15px;">
<button class="btn-secondary" onclick="setCalibrationPoint('midpoint')">Set Midpoint</button>
<button class="btn-secondary" onclick="setCalibrationPoint('stop_down')">Set Stop Down</button>
<button class="btn-secondary" onclick="setCalibrationPoint('stop_up')">Set Stop Up</button>
</div>
<button class="btn-warning" onclick="resetCalibration()" style="margin-bottom: 15px;">Reset Calibration</button>
<div id="calibration_status" style="padding: 10px; margin: 10px 0; border-radius: 5px; background: #f5f5f5; min-height: 20px;">
<div><strong>Midpoint:</strong> <span id="cal_midpoint">Not set</span></div>
<div><strong>Stop Down:</strong> <span id="cal_stop_down">Not set</span></div>
<div><strong>Stop Up:</strong> <span id="cal_stop_up">Not set</span></div>
</div>
<button class="btn-primary" onclick="calculateCalibration()" style="margin-top: 10px;">Calculate Values</button>
<div id="calibration_results" style="margin-top: 15px; padding: 15px; border-radius: 5px; background: #e8f5e9; display: none;">
<h3 style="margin-top: 0; color: #2e7d32;">Calibration Results</h3>
<p style="color: #666; font-size: 14px; margin-bottom: 15px;">Update these values in <code>motion_planner.h</code>:</p>
<div style="background: white; padding: 15px; border-radius: 5px; font-family: monospace; font-size: 13px; line-height: 1.8;">
<div style="margin-bottom: 10px;"><strong>Constants to update:</strong></div>
<div style="background: #f5f5f5; padding: 10px; border-radius: 3px; margin-bottom: 10px;">
<div>#define TILT_STEPS_PER_DEGREE <span id="result_steps_per_degree">-</span></div>
<div>#define TILT_MAX_DEGREES_DOWN <span id="result_max_degrees_down">-</span></div>
<div>#define TILT_MAX_DEGREES_UP <span id="result_max_degrees_up">-</span></div>
</div>
<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ddd;">
<strong>Calculated Limits (in steps, relative to midpoint = 0):</strong><br>
Min (Down): <span id="result_min_steps">-</span> steps<br>
Max (Up): <span id="result_max_steps">-</span> steps<br>
<span style="color: #666; font-size: 11px;">(These are automatically calculated in motion_planner.c based on the constants above)</span>
</div>
<div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #ddd; color: #666; font-size: 12px;">
<strong>Note:</strong> After updating the code, rebuild and flash the firmware. The limits will be automatically set based on these values when the system initializes.
</div>
</div>
</div>
</div>
</div>
<div class="section">
<h2>Firmware Update (OTA)</h2>
<p style="color: #666; font-size: 14px;">Upload a new firmware binary file to update the device over-the-air.</p>
<input type="file" id="firmware_file" accept=".bin" style="margin: 10px 0; padding: 5px; width: 100%; max-width: 400px; border: 1px solid #ddd; border-radius: 4px;">
<button class="btn-warning" onclick="uploadFirmware()" style="margin-top: 10px;">Upload Firmware</button>
<div id="ota_status" style="margin-top: 10px; padding: 10px; border-radius: 5px; display: none;"></div>
</div>
<div class="section">
<h2>Presets</h2>
<div class="preset-grid" id="preset_grid"></div>
<div style="margin-top: 10px;">
<button class="btn-warning" onclick="savePreset()">Save Current Position</button>
<input type="number" id="preset_save_idx" min="1" max="15" value="1" style="width: 60px; padding: 5px; margin-left: 10px;">
</div>
</div>
<div id="preset_editor_modal" class="modal">
<div class="modal-content">
<div class="modal-header">
<h2>Edit Preset <span id="editor_preset_idx">0</span></h2>
<span class="close" onclick="closePresetEditor()">&times;</span>
</div>
<form id="preset_editor_form">
<div class="form-group">
<h3>Position</h3>
<div class="form-row">
<div><label>PAN:</label><input type="number" id="editor_pos_pan" step="0.1"></div>
<div><label>TILT:</label><input type="number" id="editor_pos_tilt" step="0.1"></div>
<div><label>ZOOM:</label><input type="number" id="editor_pos_zoom" step="0.1"></div>
</div>
</div>
<div class="form-group">
<h3>Motion Parameters</h3>
<div class="form-row">
<div><label>Duration (s, 0=auto):</label><input type="number" id="editor_duration" min="0" step="0.1"></div>
<div><label>Max Speed Scale:</label><input type="number" id="editor_speed_scale" min="0" step="0.1"></div>
</div>
<div class="form-row">
<div><label>Speed Multiplier:</label><input type="number" id="editor_speed_mult" min="0.1" max="10" step="0.1" value="1.0"></div>
<div><label>Accel Multiplier:</label><input type="number" id="editor_accel_mult" min="0.1" max="10" step="0.1" value="1.0"></div>
</div>
<div><label>Easing Type:</label>
<select id="editor_easing">
<option value="0">Linear</option>
<option value="1">Smootherstep</option>
<option value="2">Sigmoid</option>
</select></div>
<div><label>Approach Mode:</label>
<select id="editor_approach">
<option value="0">Direct</option>
<option value="1">Home First</option>
<option value="2">Safe Route</option>
</select></div>
</div>
<div class="form-group">
<h3>Advanced</h3>
<div><label>Arrival Overshoot:</label><input type="number" id="editor_overshoot" min="0" max="0.01" step="0.001"></div>
<div><label><input type="checkbox" id="editor_precision"> Precision Preferred</label></div>
</div>
<div style="margin-top: 20px; text-align: right;">
<button type="button" class="btn-secondary" onclick="closePresetEditor()">Cancel</button>
<button type="button" class="btn-primary" onclick="savePresetEditor()" style="margin-left: 10px;">Save</button>
</div>
</form>
</div>
</div>
</div>
<script>
let precisionMode = false;
let updatePosInterval;
let joystickXYActive = false;
let joystickZActive = false;
let currentVelocities = {pan: 0, tilt: 0, zoom: 0};
const MAX_VELOCITY = 500;
const MAX_VELOCITY_ZOOM = 50;
function updatePositions() {
  const posEl = document.getElementById('positions');
  if (!posEl) {
    console.error('positions element not found');
    return;
  }
  fetch('/api/positions').then(r => {
    if (!r.ok) {
      throw new Error('HTTP ' + r.status);
    }
    return r.json();
  }).then(data => {
    if (data && typeof data.pan === 'number' && typeof data.tilt === 'number' && typeof data.zoom === 'number') {
      posEl.textContent = `PAN: ${data.pan.toFixed(1)} | TILT: ${data.tilt.toFixed(1)} | ZOOM: ${data.zoom.toFixed(1)}`;
    } else {
      console.error('Invalid position data:', data);
      posEl.textContent = 'Error: Invalid data';
    }
  }).catch(e => {
    console.error('Failed to fetch positions:', e);
    if (posEl) {
      posEl.textContent = 'Error loading position';
    }
  });
}
function sendVelocities(pan, tilt, zoom) {
  currentVelocities = {pan, tilt, zoom};
  fetch('/api/velocity', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({pan, tilt, zoom})
  }).catch(e => console.error('Failed to set velocity:', e));
}
function updateJoystickXY(x, y) {
  const joystick = document.getElementById('joystick_xy');
  const rect = joystick.getBoundingClientRect();
  const centerX = rect.left + rect.width / 2;
  const centerY = rect.top + rect.height / 2;
  const radius = rect.width / 2 - 15;
  const dx = x - centerX;
  const dy = y - centerY;
  const distance = Math.min(Math.sqrt(dx * dx + dy * dy), radius);
  const angle = Math.atan2(dy, dx);
  const posX = Math.cos(angle) * distance;
  const posY = Math.sin(angle) * distance;
  joystick.style.setProperty('--x', posX + 'px');
  joystick.style.setProperty('--y', posY + 'px');
  const normalizedX = posX / radius;
  const normalizedY = posY / radius;
  const velX = normalizedX * MAX_VELOCITY;
  const velY = normalizedY * MAX_VELOCITY;
  document.getElementById('xy_value').textContent = `X: ${velX.toFixed(1)}, Y: ${velY.toFixed(1)}`;
  sendVelocities(velX, velY, currentVelocities.zoom);
  document.getElementById('pan_vel').value = velX;
  document.getElementById('tilt_vel').value = velY;
  document.getElementById('pan_val').textContent = velX.toFixed(1);
  document.getElementById('tilt_val').textContent = velY.toFixed(1);
}
function updateJoystickZ(y) {
  const joystick = document.getElementById('joystick_z');
  const rect = joystick.getBoundingClientRect();
  const centerY = rect.top + rect.height / 2;
  const height = rect.height - 30;
  const dy = y - centerY;
  const normalized = Math.max(-1, Math.min(1, dy / (height / 2)));
  const posY = normalized * (height / 2);
  joystick.style.setProperty('--y', posY + 'px');
  const velZ = normalized * MAX_VELOCITY_ZOOM;
  document.getElementById('z_value').textContent = `Z: ${velZ.toFixed(1)}`;
  sendVelocities(currentVelocities.pan, currentVelocities.tilt, velZ);
  document.getElementById('zoom_vel').value = velZ;
  document.getElementById('zoom_val').textContent = velZ.toFixed(1);
}
function resetJoystickXY() {
  const joystick = document.getElementById('joystick_xy');
  joystick.classList.remove('active');
  joystick.style.setProperty('--x', '0px');
  joystick.style.setProperty('--y', '0px');
  document.getElementById('xy_value').textContent = 'X: 0.0, Y: 0.0';
  sendVelocities(0, 0, currentVelocities.zoom);
  document.getElementById('pan_vel').value = 0;
  document.getElementById('tilt_vel').value = 0;
  document.getElementById('pan_val').textContent = '0.0';
  document.getElementById('tilt_val').textContent = '0.0';
}
function resetJoystickZ() {
  const joystick = document.getElementById('joystick_z');
  joystick.classList.remove('active');
  joystick.style.setProperty('--y', '0px');
  document.getElementById('z_value').textContent = 'Z: 0.0';
  sendVelocities(currentVelocities.pan, currentVelocities.tilt, 0);
  document.getElementById('zoom_vel').value = 0;
  document.getElementById('zoom_val').textContent = '0.0';
}
const joystickXY = document.getElementById('joystick_xy');
joystickXY.addEventListener('mousedown', (e) => {
  joystickXYActive = true;
  joystickXY.classList.add('active');
  updateJoystickXY(e.clientX, e.clientY);
});
joystickXY.addEventListener('mousemove', (e) => {
  if (joystickXYActive) updateJoystickXY(e.clientX, e.clientY);
});
joystickXY.addEventListener('mouseup', () => {
  joystickXYActive = false;
  resetJoystickXY();
});
joystickXY.addEventListener('mouseleave', () => {
  if (joystickXYActive) {
    joystickXYActive = false;
    resetJoystickXY();
  }
});
joystickXY.addEventListener('touchstart', (e) => {
  e.preventDefault();
  joystickXYActive = true;
  joystickXY.classList.add('active');
  const touch = e.touches[0];
  updateJoystickXY(touch.clientX, touch.clientY);
});
joystickXY.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (joystickXYActive && e.touches.length > 0) {
    const touch = e.touches[0];
    updateJoystickXY(touch.clientX, touch.clientY);
  }
});
joystickXY.addEventListener('touchend', (e) => {
  e.preventDefault();
  joystickXYActive = false;
  resetJoystickXY();
});
const joystickZ = document.getElementById('joystick_z');
joystickZ.addEventListener('mousedown', (e) => {
  joystickZActive = true;
  joystickZ.classList.add('active');
  updateJoystickZ(e.clientY);
});
joystickZ.addEventListener('mousemove', (e) => {
  if (joystickZActive) updateJoystickZ(e.clientY);
});
joystickZ.addEventListener('mouseup', () => {
  joystickZActive = false;
  resetJoystickZ();
});
joystickZ.addEventListener('mouseleave', () => {
  if (joystickZActive) {
    joystickZActive = false;
    resetJoystickZ();
  }
});
joystickZ.addEventListener('touchstart', (e) => {
  e.preventDefault();
  joystickZActive = true;
  joystickZ.classList.add('active');
  const touch = e.touches[0];
  updateJoystickZ(touch.clientY);
});
joystickZ.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (joystickZActive && e.touches.length > 0) {
    const touch = e.touches[0];
    updateJoystickZ(touch.clientY);
  }
});
joystickZ.addEventListener('touchend', (e) => {
  e.preventDefault();
  joystickZActive = false;
  resetJoystickZ();
});
function handleGlobalMouseUp() {
  if (joystickXYActive) {
    joystickXYActive = false;
    resetJoystickXY();
  }
  if (joystickZActive) {
    joystickZActive = false;
    resetJoystickZ();
  }
}
document.addEventListener('mouseup', handleGlobalMouseUp, true);
document.addEventListener('touchend', handleGlobalMouseUp, true);
document.addEventListener('touchcancel', handleGlobalMouseUp, true);
document.addEventListener('mousemove', (e) => {
  if (joystickXYActive) updateJoystickXY(e.clientX, e.clientY);
  if (joystickZActive) updateJoystickZ(e.clientY);
});
function updateVelocities() {
  if (joystickXYActive || joystickZActive) return;
  const pan = parseFloat(document.getElementById('pan_vel').value);
  const tilt = parseFloat(document.getElementById('tilt_vel').value);
  const zoom = parseFloat(document.getElementById('zoom_vel').value);
  document.getElementById('pan_val').textContent = pan.toFixed(1);
  document.getElementById('tilt_val').textContent = tilt.toFixed(1);
  document.getElementById('zoom_val').textContent = zoom.toFixed(1);
  sendVelocities(pan, tilt, zoom);
}
document.getElementById('pan_vel').addEventListener('input', updateVelocities);
document.getElementById('tilt_vel').addEventListener('input', updateVelocities);
document.getElementById('zoom_vel').addEventListener('input', updateVelocities);
function sendCommand(cmd) {
  fetch('/api/command', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({command: cmd})
  }).then(r => r.json()).then(data => {
    if (data.status === 'ok') {
      alert('Command executed: ' + cmd);
      if (cmd === 'precision') precisionMode = !precisionMode;
    } else {
      alert('Error: ' + (data.error || 'Unknown error'));
    }
  }).catch(e => {
    console.error('Command failed:', e);
    alert('Failed to send command');
  });
}
function gotoPreset(idx) {
  fetch('/api/preset/goto', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({index: idx})
  }).then(r => r.json()).then(data => {
    if (data.status === 'ok') {
      alert('Moving to preset ' + idx);
    } else {
      alert('Error: ' + (data.error || 'Failed to move to preset'));
    }
  }).catch(e => {
    console.error('Goto preset failed:', e);
    alert('Failed to move to preset');
  });
}
function savePreset() {
  const idx = parseInt(document.getElementById('preset_save_idx').value);
  fetch('/api/preset/save', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({index: idx})
  }).then(r => r.json()).then(data => {
    if (data.status === 'ok') {
      alert('Preset ' + idx + ' saved!');
      createPresetButtons();
    } else {
      alert('Error: ' + (data.error || 'Failed to save preset'));
    }
  }).catch(e => {
    console.error('Save preset failed:', e);
    alert('Failed to save preset');
  });
}
function createPresetButtons() {
  const grid = document.getElementById('preset_grid');
  if (!grid) {
    console.error('preset_grid element not found');
    return;
  }
  grid.innerHTML = '';
  // Preset 0 is hidden (always 0,0,0), start from 1
  for (let i = 1; i < 16; i++) {
    const btn = document.createElement('button');
    btn.className = 'btn-secondary preset-btn';
    btn.textContent = 'Preset ' + i;
    btn.onclick = () => gotoPreset(i);
    const editBtn = document.createElement('button');
    editBtn.className = 'preset-edit-btn';
    editBtn.textContent = 'Edit';
    editBtn.onclick = (e) => { e.stopPropagation(); openPresetEditor(i); };
    btn.appendChild(editBtn);
    grid.appendChild(btn);
  }
}
let currentEditingPreset = -1;
function openPresetEditor(idx) {
  // Preset 0 is read-only and cannot be edited
  if (idx === 0) {
    alert('Preset 0 is read-only and always returns to position 0,0,0');
    return;
  }
  currentEditingPreset = idx;
  document.getElementById('editor_preset_idx').textContent = idx;
  document.getElementById('preset_editor_modal').style.display = 'block';
  fetch('/api/preset/get?index=' + idx).then(r => r.json()).then(data => {
    if (data.status === 'ok' && data.preset) {
      const p = data.preset;
      document.getElementById('editor_pos_pan').value = p.pos[0] || 0;
      document.getElementById('editor_pos_tilt').value = p.pos[1] || 0;
      document.getElementById('editor_pos_zoom').value = p.pos[2] || 0;
      document.getElementById('editor_duration').value = p.duration_s || 0;
      document.getElementById('editor_speed_scale').value = p.max_speed_scale || 0;
      document.getElementById('editor_speed_mult').value = p.speed_multiplier || 1.0;
      document.getElementById('editor_accel_mult').value = p.accel_multiplier || 1.0;
      document.getElementById('editor_easing').value = p.easing_type || 0;
      document.getElementById('editor_approach').value = p.approach_mode || 0;
      document.getElementById('editor_overshoot').value = p.arrival_overshoot || 0;
      document.getElementById('editor_precision').checked = p.precision_preferred || false;
    } else {
      document.getElementById('editor_pos_pan').value = 0;
      document.getElementById('editor_pos_tilt').value = 0;
      document.getElementById('editor_pos_zoom').value = 0;
      document.getElementById('editor_duration').value = 0;
      document.getElementById('editor_speed_scale').value = 0;
      document.getElementById('editor_speed_mult').value = 1.0;
      document.getElementById('editor_accel_mult').value = 1.0;
      document.getElementById('editor_easing').value = 1;
      document.getElementById('editor_approach').value = 0;
      document.getElementById('editor_overshoot').value = 0;
      document.getElementById('editor_precision').checked = false;
    }
  }).catch(e => {
    console.error('Failed to load preset:', e);
    alert('Failed to load preset data');
  });
}
function closePresetEditor() {
  document.getElementById('preset_editor_modal').style.display = 'none';
  currentEditingPreset = -1;
}
function savePresetEditor() {
  if (currentEditingPreset < 0) return;
  const preset = {
    index: currentEditingPreset,
    pos: [
      parseFloat(document.getElementById('editor_pos_pan').value) || 0,
      parseFloat(document.getElementById('editor_pos_tilt').value) || 0,
      parseFloat(document.getElementById('editor_pos_zoom').value) || 0
    ],
    duration_s: parseFloat(document.getElementById('editor_duration').value) || 0,
    max_speed_scale: parseFloat(document.getElementById('editor_speed_scale').value) || 0,
    speed_multiplier: parseFloat(document.getElementById('editor_speed_mult').value) || 1.0,
    accel_multiplier: parseFloat(document.getElementById('editor_accel_mult').value) || 1.0,
    easing_type: parseInt(document.getElementById('editor_easing').value) || 0,
    approach_mode: parseInt(document.getElementById('editor_approach').value) || 0,
    arrival_overshoot: parseFloat(document.getElementById('editor_overshoot').value) || 0,
    precision_preferred: document.getElementById('editor_precision').checked,
    valid: true
  };
  fetch('/api/preset/update', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(preset)
  }).then(r => r.json()).then(data => {
    if (data.status === 'ok') {
      alert('Preset ' + currentEditingPreset + ' updated!');
      closePresetEditor();
    } else {
      alert('Error: ' + (data.error || 'Failed to update preset'));
    }
  }).catch(e => {
    console.error('Update preset failed:', e);
    alert('Failed to update preset');
  });
}
window.onclick = function(event) {
  const modal = document.getElementById('preset_editor_modal');
  if (event.target == modal) {
    closePresetEditor();
  }
};
function uploadFirmware() {
  const fileInput = document.getElementById('firmware_file');
  const statusDiv = document.getElementById('ota_status');
  if (!fileInput || !fileInput.files || fileInput.files.length === 0) {
    if (statusDiv) {
      statusDiv.style.display = 'block';
      statusDiv.className = 'status status-info';
      statusDiv.textContent = 'Please select a firmware file first';
    }
    return;
  }
  const file = fileInput.files[0];
  if (statusDiv) {
    statusDiv.style.display = 'block';
    statusDiv.className = 'status status-info';
    statusDiv.textContent = 'Uploading firmware (' + (file.size / 1024 / 1024).toFixed(2) + ' MB)...';
  }
  fetch('/api/update', {
    method: 'POST',
    headers: { 'Content-Type': 'application/octet-stream' },
    body: file
  }).then(response => {
    if (!response.ok) {
      throw new Error('HTTP ' + response.status);
    }
    return response.json();
  }).then(data => {
    if (statusDiv) {
      if (data.status === 'ok') {
        statusDiv.className = 'status status-success';
        statusDiv.textContent = 'Firmware uploaded successfully! Device will reboot in a few seconds...';
        setTimeout(() => {
          if (statusDiv) {
            statusDiv.textContent = 'Device rebooting. Please wait and refresh the page in 30 seconds.';
          }
        }, 2000);
      } else {
        statusDiv.className = 'status status-info';
        statusDiv.style.background = '#ffebee';
        statusDiv.style.color = '#c62828';
        statusDiv.textContent = 'Error: ' + (data.error || 'Upload failed');
      }
    }
  }).catch(e => {
    console.error('Upload failed:', e);
    if (statusDiv) {
      statusDiv.className = 'status status-info';
      statusDiv.style.background = '#ffebee';
      statusDiv.style.color = '#c62828';
      statusDiv.textContent = 'Upload failed: ' + e.message;
    }
  });
}
let calibrationData = {
  midpoint: null,
  stop_down: null,
  stop_up: null
};

function setCalibrationPoint(type) {
  fetch('/api/positions').then(r => r.json()).then(data => {
    if (data && typeof data.tilt === 'number') {
      calibrationData[type] = data.tilt;
      updateCalibrationStatus();
    } else {
      alert('Failed to get current position');
    }
  }).catch(e => {
    console.error('Failed to get position:', e);
    alert('Failed to get current position');
  });
}

function updateCalibrationStatus() {
  document.getElementById('cal_midpoint').textContent = 
    calibrationData.midpoint !== null ? calibrationData.midpoint.toFixed(2) + ' steps' : 'Not set';
  document.getElementById('cal_stop_down').textContent = 
    calibrationData.stop_down !== null ? calibrationData.stop_down.toFixed(2) + ' steps' : 'Not set';
  document.getElementById('cal_stop_up').textContent = 
    calibrationData.stop_up !== null ? calibrationData.stop_up.toFixed(2) + ' steps' : 'Not set';
}

function resetCalibration() {
  calibrationData = {
    midpoint: null,
    stop_down: null,
    stop_up: null
  };
  updateCalibrationStatus();
  document.getElementById('calibration_results').style.display = 'none';
}

function calculateCalibration() {
  if (calibrationData.midpoint === null || calibrationData.stop_down === null || calibrationData.stop_up === null) {
    alert('Please set all three points (Midpoint, Stop Down, and Stop Up) before calculating.');
    return;
  }
  
  // Calculate relative positions from midpoint (in steps)
  // Midpoint is treated as position 0 (home position)
  const down_relative = calibrationData.stop_down - calibrationData.midpoint;
  const up_relative = calibrationData.stop_up - calibrationData.midpoint;
  
  // Down should be negative (less than midpoint), Up should be positive (greater than midpoint)
  // Ensure we have the correct min (down, negative) and max (up, positive)
  const min_relative = Math.min(down_relative, up_relative);  // Should be negative (down)
  const max_relative = Math.max(down_relative, up_relative);  // Should be positive (up)
  
  // Calculate total range in steps
  const total_range_steps = max_relative - min_relative;
  
  // To calculate steps per degree, we need to know the actual degrees
  // We'll use a typical camera tilt range as a reference (e.g., 90 degrees total)
  // or calculate from a reasonable assumption
  // For now, let's use the approach: calculate steps per degree from a typical range
  // Typical camera tilt: down ~30 degrees, up ~60 degrees = 90 degrees total
  // But we'll calculate based on the actual measured range
  
  // Estimate: if we assume a typical steps_per_degree (like 0.556 for 200 steps/rev motor)
  // we can calculate the degrees, then refine steps_per_degree
  const typical_steps_per_degree = 0.556; // Typical value for 200 steps/rev motor
  const estimated_degrees_down = Math.abs(min_relative) / typical_steps_per_degree;
  const estimated_degrees_up = Math.abs(max_relative) / typical_steps_per_degree;
  const estimated_total_degrees = estimated_degrees_down + estimated_degrees_up;
  
  // Now calculate actual steps per degree from the total range
  const steps_per_degree = total_range_steps / estimated_total_degrees;
  
  // Recalculate degrees with the refined steps_per_degree
  const degrees_down_actual = Math.abs(min_relative) / steps_per_degree;
  const degrees_up_actual = Math.abs(max_relative) / steps_per_degree;
  
  // Display results
  document.getElementById('result_steps_per_degree').textContent = steps_per_degree.toFixed(6) + 'f';
  document.getElementById('result_max_degrees_down').textContent = degrees_down_actual.toFixed(2) + 'f';
  document.getElementById('result_max_degrees_up').textContent = degrees_up_actual.toFixed(2) + 'f';
  document.getElementById('result_min_steps').textContent = min_relative.toFixed(2);
  document.getElementById('result_max_steps').textContent = max_relative.toFixed(2);
  
  document.getElementById('calibration_results').style.display = 'block';
  
  // Scroll to results
  document.getElementById('calibration_results').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

setTimeout(function() {
  try {
    updatePositions();
    updatePosInterval = setInterval(updatePositions, 500);
    createPresetButtons();
  } catch (e) {
    console.error('Initialization error:', e);
  }
}, 100);
</script>
</body></html>

